<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>Learn SR Linux</title><description>Open documentation for open Network OS</description><link>https://learn.srlinux.dev/</link><atom:link href="https://learn.srlinux.dev/feed_rss_created.xml" rel="self" type="application/rss+xml" /><managingEditor>SR Linux</managingEditor><docs>https://github.com/srl-labs/learn-srlinux</docs><language>en</language> <pubDate>Tue, 02 May 2023 18:43:35 -0000</pubDate> <lastBuildDate>Tue, 02 May 2023 18:43:35 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.5.0</generator> <item> <title>Official Ansible collection for SR Linux</title> <author>rdodin</author> <category>ansible</category> <category>sr linux</category> <description>&lt;h1&gt;Official Ansible collection for SR Linux&lt;/h1&gt;&lt;p&gt;Ever since we released a tutorial that showed how to use Ansible&#39;s URI module with SR Linux, we couldn&#39;t shake off the feeling that we would need to do more with Ansible. And we did.&lt;br&gt;We are happy to announce that we have released an official Ansible collection for SR Linux - [&lt;code&gt;nokia.srlinux&lt;/code&gt;][collection-doc-link] - that has four modules inside and leverages &lt;a href=&#34;../2022/json-rpc-basics.md&#34;&gt;JSON-RPC interface&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;In this blog post, we would like to share some details about our design decisions and why we think this collection is a great addition to the Ansible ecosystem.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;Deficiencies of the URI module&lt;/h2&gt;&lt;p&gt;The URI module is a great tool for making REST API calls. It is very flexible, generic and can be used to make any type of HTTP/RESTAPI calls. However, its generic nature can also be seen as a drawback.&lt;/p&gt;&lt;h3&gt;Verbosity&lt;/h3&gt;&lt;p&gt;The verbosity that comes with URI module can&#39;t be ignored. It requires a lot of wiring to be done before the request is ready. Consider the following example where we want to update &lt;code&gt;/system/information&lt;/code&gt; container:&lt;/p&gt;&lt;p&gt;&lt;code&gt;yaml- name: Configuration hosts: all connection: local gather_facts: no tasks: - name: Various configuration tasks ansible.builtin.uri: url: http://{{inventory_hostname}}/jsonrpc url_username: admin url_password: NokiaSrl1! method: POST body: jsonrpc: &#34;2.0&#34; id: 1 method: set params: commands: - action: update path: /system/information value: location: the Netherlands contact: Roman Dodin body_format: json&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Parameters like &lt;code&gt;url&lt;/code&gt;, &lt;code&gt;url_username&lt;/code&gt;, &lt;code&gt;url_password&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; are all required and must be specified for every request. This makes the code very verbose and hard to read. Using variables won&#39;t help much either, as the parameters still need to be explicitly set.&lt;/p&gt;&lt;p&gt;With a custom module we can hide all the boilerplate code and make the request contain only the intent:&lt;/p&gt;&lt;p&gt;&lt;code&gt;yaml- name: Configuration hosts: all gather_facts: false tasks: - name: Various configuration tasks nokia.srlinux.config: update: - path: /system/information value: location: the Netherlands contact: Roman Dodin&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;Error handling&lt;/h3&gt;&lt;p&gt;The URI module doesn&#39;t provide any error handling besides the HTTP error codes returned by the server. In case the errors are returned by the application and not a server, it becomes the user&#39;s problem to check the response body for error messages. This is not a problem if you are making a single request, but if you are making multiple requests, you will need to check the response code for each request. This can be done using &lt;code&gt;register&lt;/code&gt; and &lt;code&gt;failed_when&lt;/code&gt; parameters, but it is not convenient.&lt;/p&gt;&lt;p&gt;In a custom module you are in full control of the error handling and can make decisions based on the response body. For example, you can check if the response contains an error message and fail the task if it does with a clean error message.&lt;/p&gt;&lt;h3&gt;Idempotency&lt;/h3&gt;&lt;p&gt;A common problem with the URI module is idempotency. The module doesn&#39;t provide any means to check if the configuration is already present on the device without writing additional requests as part of the playbook. This means that the user needs to implement the idempotency logic themselves.&lt;/p&gt;&lt;p&gt;In a custom module, you can implement the idempotency logic and make the module idempotent by default. This means that the user doesn&#39;t need to worry about idempotency and can focus on the intent.&lt;/p&gt;&lt;h3&gt;Check and Diff&lt;/h3&gt;&lt;p&gt;Besides idempotency, the with URI module it is impossible to implement the &lt;code&gt;check&lt;/code&gt; and &lt;code&gt;diff&lt;/code&gt; functionality which is table stakes for network automation. Another requirement that warrants a custom module development.&lt;/p&gt;&lt;h2&gt;Design decisions&lt;/h2&gt;&lt;p&gt;So, all these fallacies of the URI module led us to the decision to develop a custom module for SR Linux. We wanted to make the module as easy to use as possible, while keeping the generic nature.&lt;/p&gt;&lt;h3&gt;Network resource vs generic module&lt;/h3&gt;&lt;p&gt;The first decision we had to make was whether to follow a network resource module principles or stick with a generic module approach.&lt;/p&gt;&lt;p&gt;The &lt;a href=&#34;https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html&#34;&gt;network resource module&lt;/a&gt; approach says that developers should create a module for each configuration section. For example, a separate module to configure VLANs, another one to configure BGP, a third one to configure EVPN, and so on.&lt;/p&gt;&lt;p&gt;The generic module philosophy is different. Instead of creating a horde of modules, you create a single module per distinct operation and use the module parameters to specify the intent. For example, a module to configure the network device may be called &lt;code&gt;config&lt;/code&gt; and a module to retrieve information from it - &lt;code&gt;get&lt;/code&gt;.&lt;br&gt;The &lt;code&gt;config&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt; modules will have a parame...&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2023/official-ansible-collection-for-sr-linux/</link> <pubDate>Tue, 02 May 2023 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2023/official-ansible-collection-for-sr-linux/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2023/official-ansible-collection-for-sr-linux/</guid> </item> <item> <title> Event-Driven Automation With Nokia’s SR Linux Event Handler Framework</title> <category>event handler</category> <category>media</category> <category>packet pushers</category> <category>podcast</category> <description>&lt;h1&gt;:material-podcast: Event-Driven Automation With Nokia’s SR Linux Event Handler Framework&lt;/h1&gt;&lt;p&gt;&lt;small&gt;:material-podcast: &lt;a href=&#34;https://packetpushers.net/podcast/tech-bytes-event-driven-automation-with-nokias-sr-linux-event-handler-framework-sponsored/&#34;&gt;Packet Pushers&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;&lt;p&gt;In this Tech Bytes podcast we talk about Event Handler, a new automation feature in Nokia’s SR Linux network OS that lets you automatically run scripts to fix problems when an event occurs.&lt;/p&gt;&lt;p&gt;We discuss:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SR Linux’s modular design&lt;/li&gt;&lt;li&gt;The new Event Handler Framework&lt;/li&gt;&lt;li&gt;How Event Handler works&lt;/li&gt;&lt;li&gt;Use cases for network engineers and operations teams&lt;/li&gt;&lt;/ul&gt;&lt;div class=&#34;iframe-audio2-container&#34;&gt;&lt;iframe width=&#34;320&#34; height=&#34;30&#34; src=&#34;https://packetpushers.net/?powerpress_embed=52038-podcast&amp;amp;powerpress_player=mediaelement-audio&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;Participants: &lt;a href=&#34;https://twitter.com/ntdvps&#34;&gt;:material-twitter:&lt;/a&gt;&lt;a href=&#34;https://linkedin.com/in/rdodin&#34;&gt;:material-linkedin:&lt;/a&gt; Roman Dodin&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2023/material-podcast-event-driven-automation-with-nokias-sr-linux-event-handler-framework/</link> <pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2023/material-podcast-event-driven-automation-with-nokias-sr-linux-event-handler-framework/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2023/material-podcast-event-driven-automation-with-nokias-sr-linux-event-handler-framework/</guid> </item> <item> <title>SR Linux logging with ELK</title> <author>azyablov</author> <author>rdodin</author> <category>elk</category> <category>logging</category> <category>sr linux</category> <category>syslog</category> <description>&lt;h1&gt;SR Linux logging with ELK&lt;/h1&gt;&lt;p&gt;&lt;small&gt;&lt;strong&gt;Join the discussion:&lt;/strong&gt; [:material-linkedin: LinkedIn post][discussion-linkedin] · [:material-twitter: Twitter thread][discussion-twitter]&lt;/small&gt;&lt;/p&gt;&lt;p&gt;In a not-so-distant past, manually extracting, parsing, and reading log files produced by network elements was standard practice for a sysadmin. With arcane piping of old-but-good &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, and &lt;code&gt;sed&lt;/code&gt; tools, one could swiftly identify a problem in a relatively large system. This was a viable approach for quite some time, but it became prey to a massive scale.&lt;/p&gt;&lt;p&gt;Today&#39;s network infrastructures often count thousands of elements, each emitting log messages. Getting through a log collection of this size with CLI tools designed decades ago might not be the best tactic. As well as correlating logs between network elements and application logs might be impossible without software solutions built with such use cases in mind.&lt;/p&gt;&lt;p&gt;The unprecedented growth in the application world boosted the development of multi-purposed centralized/cloud data collectors that make observability and discovery over huge data sets a reality. Elasticsearch / Logstash / Kibana (or ELK for short) is one of the most known open-source stacks tailored for the collection and processing of various documents, logs included.&lt;/p&gt;&lt;p&gt;To enable the processing of captured logs and deliver performant and robust search analytics log collectors rely on structured data. Unfortunately, the networking world is infamous for iterating slowly. For example, an outdated and informational [Syslog][syslog-wiki] interface still dominates the networking space when it comes to managing and transferring logs. &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc3164&#34;&gt;Syslog RFC3164&lt;/a&gt;[^4] was not designed to allow extensible structured payloads, which adds a fair share of problems with integrating such systems with modern log collectors.&lt;/p&gt;&lt;p&gt;This post explains how an SR Linux-powered DC fabric can be integrated with a modern logging infrastructure based on the Elasticsearch / Logstash / Kibana stack to collect, transform, handle, and view logs.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;Lab&lt;/h2&gt;&lt;p&gt;As you would have expected, the post is accompanied by the [containerlab][clab-install]-based [lab][topo-file] that consists of an SR Linux fabric and ELK stack.&lt;br&gt;DC Fabric comes preconfigured with an EVPN-VXLAN L2 domain instance, and syslog-based logging is set up on the SR Linux network elements.&lt;/p&gt;&lt;p&gt;!!!note Anyone can spin this lab on their machine since all the lab elements are using official public container images.&lt;/p&gt;&lt;p&gt;| Summary | || :-------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------- || &lt;strong&gt;Lab name&lt;/strong&gt; | SR Linux fabric with ELK stack || &lt;strong&gt;Lab components&lt;/strong&gt; | Nokia SR Linux, ELK stack || &lt;strong&gt;Resource requirements&lt;/strong&gt; | :fontawesome-solid-microchip: 6 vCPU &lt;br/&gt;:fontawesome-solid-memory: 12 GB || &lt;strong&gt;Lab&lt;/strong&gt; | [srl-labs/srl-elk-lab][lab-repo] || &lt;strong&gt;Version information&lt;/strong&gt;[^1] | [&lt;code&gt;containerlab:0.36.1&lt;/code&gt;][clab-install], [&lt;code&gt;srlinux:22.11.1&lt;/code&gt;][srl-container], ELK stack 7.17.7 || &lt;strong&gt;Authors&lt;/strong&gt; | Anton Zyablov [:material-linkedin:][azyablov-linkedin] &lt;br/&gt; Roman Dodin [:material-twitter:][rd-twitter] [:material-linkedin:][rd-linkedin] |&lt;/p&gt;&lt;p&gt;[Lab repository][lab-repo] contains all necessary configuration artifacts, which are mounted to the respective container nodes as outlined in the [topology file][topo-file].&lt;/p&gt;&lt;h3&gt;Topology&lt;/h3&gt;&lt;p&gt;A 2-tier DC fabric consists of two spines and four leaves. ELK stack consists of Elasticsearch, Logstash and Kibana nodes.&lt;/p&gt;&lt;div class=&#34;mxgraph&#34; style=&#34;max-width:100%;border:1px solid transparent;margin:0 auto; display:block;&#34; data-mxgraph=&#34;{&amp;quot;page&amp;quot;:1,&amp;quot;zoom&amp;quot;:2,&amp;quot;highlight&amp;quot;:&amp;quot;#0000ff&amp;quot;,&amp;quot;nav&amp;quot;:true,&amp;quot;check-visible-state&amp;quot;:true,&amp;quot;resize&amp;quot;:true,&amp;quot;url&amp;quot;:&amp;quot;https://raw.githubusercontent.com/srl-labs/srl-elk-lab/diagrams/elk.drawio&amp;quot;}&#34;&gt;&lt;/div&gt;&lt;p&gt;Two clients emulated with Linux containers are connected to the leaves.&lt;/p&gt;&lt;h3&gt;Deployment&lt;/h3&gt;&lt;p&gt;Prior to deploying the lab, make sure that containerlab is [installed][clab-install]. The following installation script installs containerlab on most Linux systems.&lt;/p&gt;&lt;p&gt;```bash title=&#34;Containerlab installation via installation-script&#34;bash -c &#34;$(curl -sL https://get.con...&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2023/sr-linux-logging-with-elk/</link> <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2023/sr-linux-logging-with-elk/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2023/sr-linux-logging-with-elk/</guid> </item> <item> <title>SR Linux Syntax Highlighting with Pygments</title> <author>rdodin</author> <category>pygments</category> <category>sr linux</category> <description>&lt;h1&gt;SR Linux Syntax Highlighting with Pygments&lt;/h1&gt;&lt;p&gt;For a very long time, I wanted to make a syntax highlighter for the SR Linux command-line interface mainly because I belong to a cohort of readers who appreciate visual aids in lengthy CLI snippets. Give me a piece of code that is not syntax highlighted, and my reading speed will significantly drop.&lt;/p&gt;&lt;p&gt;And even though the Network OS CLI snippets do not contain code per-se, they have markers (such as a current command, IP addresses, up/down statuses, etc.) that when highlighted, contribute to the clarity of the provided snippet.&lt;/p&gt;&lt;p&gt;So during a lazy first Thursday of 2023 I finally made myself looking into it and created the [&lt;code&gt;srlinux-pygments&lt;/code&gt;][srl-pygments-repo] - a &lt;a href=&#34;https://pygments.org/&#34;&gt;Pygments&lt;/a&gt; lexer to highlight SR Linux CLI snippets.&lt;/p&gt;&lt;p&gt;=== &#34;Raw text CLI snippet&#34; &lt;code&gt;--{ * candidate shared default }--[ network-instance black ]-- A:leaf1# info static-routes static-routes { route 192.168.18.0/24 { admin-state enable metric 1 preference 5 next-hop-group static-ipv4-grp } route 2001:1::192:168:18:0/64 { admin-state enable metric 1 preference 6 next-hop-group static-ipv6-grp } }&lt;/code&gt;=== &#34;With &lt;code&gt;srl&lt;/code&gt; syntax applied&#34; &lt;code&gt;srl --{ * candidate shared default }--[ network-instance black ]-- A:leaf1# info static-routes static-routes { route 192.168.18.0/24 { admin-state enable metric 1 preference 5 next-hop-group static-ipv4-grp } route 2001:1::192:168:18:0/64 { admin-state enable metric 1 preference 6 next-hop-group static-ipv6-grp } }&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Jump under the cut to know how to create a custom syntax highlighter based on SR Linux CLI example and integrate it with [mkdocs-material][mkdocs-material] doc theme.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;Pygments? Lexers?&lt;/h2&gt;&lt;p&gt;Whenever you see a nicely highlighted code block on the web, chances are high that syntax highlighting was done using [Pygments][pygments].&lt;/p&gt;&lt;p&gt;!!!info Pygments is a generic syntax highlighter suitable for use in code hosting, forums, wikis or other applications that need to prettify source code. Highlights are:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;* a wide range of 548 languages and other text formats is supported* special attention is paid to details that increase highlighting quality* support for new languages and formats are added easily; most languages use a simple regex-based lexing mechanism* a number of output formats is available, among them HTML, RTF, LaTeX and ANSI sequences* it is usable as a command-line tool and as a library&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Almost all python-based documentation engines exclusively use Pygments for syntax highlighting; [mkdocs-material][mkdocs-material] engine, which powers this learning portal, is no exception.&lt;br&gt;When you create a code block in your markdown file and annotate it with some language class, Pygments kicks in and colorizes it.&lt;/p&gt;&lt;p&gt;A [lexer][write-lexer] is a Pygments&#39; component that parses the code block&#39;s content and generates &lt;em&gt;tokens&lt;/em&gt;. Tokens are then rendered by the &lt;em&gt;formatter&lt;/em&gt; in one of the supported ways, for example, HTML code.&lt;br&gt;This might sound confusing at first, but the key takeaway here is that lexer is a python program that leverages Pygments&#39; API to parse the raw text and extract the tokens that will be highlighted later on. So when you need to create a new syntax highlighting for a custom language, you typically only need to create a new lexer.&lt;/p&gt;&lt;p&gt;Bear with me, it is less scary than it sounds :smiley:.&lt;/p&gt;&lt;h2&gt;What to highlight?&lt;/h2&gt;&lt;p&gt;Before jumping to creating our new lexer, let&#39;s draft the requirements. What do we want to highlight? There is no public standard for a Network OS CLI syntax, thus, we can choose what tokens we want to highlight.&lt;/p&gt;&lt;p&gt;Consider the following SR Linux CLI snippet that displays static routes configuration stanza:&lt;/p&gt;&lt;p&gt;```&lt;/p&gt;&lt;h1&gt;displaying configured static routes&lt;/h1&gt;&lt;p&gt;--{ * candidate shared default }--[ network-instance black ]--A:leaf1# info static-routes static-routes { route 192.168.18.0/24 { admin-state enable metric 1 preference 5 next-hop-group static-ipv4-grp } route 2001:1::192:168:18:0/64 { admin-state enable metric 1 preference 6 next-hop-group static-ipv6-grp } }```&lt;/p&gt;&lt;p&gt;In this &#34;wall of text&#34;, I think it is suitable to make the following adjustments:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Make the 1st line of the prompt less intrusive. It displays auxiliary information about the selected datastore and present context, but ...&lt;/li&gt;&lt;/ol&gt;</description><link>https://learn.srlinux.dev/blog/2023/sr-linux-syntax-highlighting-with-pygments/</link> <pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2023/sr-linux-syntax-highlighting-with-pygments/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2023/sr-linux-syntax-highlighting-with-pygments/</guid> </item> <item> <title>Using Ansible with SR Linux&#39;s JSON-RPC Interface</title> <author>rdodin</author> <category>ansible</category> <category>json-rpc</category> <category>sr linux</category> <description>&lt;h1&gt;Using Ansible with SR Linux&#39;s JSON-RPC Interface&lt;/h1&gt;&lt;p&gt;A few days after we fleshed out our &lt;a href=&#34;../../../tutorials/programmability/json-rpc/basics.md&#34;&gt;:material-book: JSON-RPC Basics&lt;/a&gt; tutorial, and we are releasing another one. While basics tutorial is essential to read to understand how the interface works, the &lt;code&gt;curl&lt;/code&gt; utility we used in the examples there is not something you would like to automate your network with.&lt;/p&gt;&lt;p&gt;Quite a lot of network ops teams we&#39;ve been talking to used Ansible to manage their infra, and they wanted to keep using it for network automation as well. While this is a questionable tactic, we still can give you the &#34;fishing rod&#34;.&lt;/p&gt;&lt;p&gt;Please welcome - &lt;strong&gt;&lt;a href=&#34;../../../tutorials/programmability/json-rpc/ansible.md&#34;&gt;:material-book: Using Ansible with SR Linux&#39;s JSON-RPC Interface&lt;/a&gt;&lt;/strong&gt; tutorial, which puts our JSON-RPC interface to work under Ansible command through a set of task-oriented exercises.&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2022/using-ansible-with-sr-linuxs-json-rpc-interface/</link> <pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/using-ansible-with-sr-linuxs-json-rpc-interface/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/using-ansible-with-sr-linuxs-json-rpc-interface/</guid> </item> <item> <title>JSON-RPC Management Interface</title> <author>rdodin</author> <category>json-rpc</category> <category>sr linux</category> <description>&lt;h1&gt;JSON-RPC Management Interface&lt;/h1&gt;&lt;p&gt;Nokia SR Linux Network OS architecture has been built on strong principles of model-driven APIs and interfaces. Not a single thing in SR Linux datastores can get away without having a matching YANG module describing it.&lt;/p&gt;&lt;p&gt;The ground-up model-driven approach allowed us to build management interfaces that don&#39;t have shortness of sight as every interface, in essence, uses the common API layer presented by the management server. One of such interfaces - JSON-RPC - that SR Linux offers has been in the shade of a cool-kid gNMI, though JSON-RPC has lots to offer.&lt;/p&gt;&lt;p&gt;We are glad to present you with an in-depth tutorial on SR Linux&#39;s JSON-RPC interface - &lt;strong&gt;&lt;a href=&#34;../../../tutorials/programmability/json-rpc/basics.md&#34;&gt;:material-book: JSON-RPC Basics&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;In this tutorial, we explain the JSON-RPC capabilities and provide practical examples for every method this interface offers. Be it retrieval of state, model-driven configuration using JSON, or pushing CLI-styled commands - JSON-RPC has you covered.&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2022/json-rpc-management-interface/</link> <pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/json-rpc-management-interface/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/json-rpc-management-interface/</guid> </item> <item> <title>Basic IXP Lab with OpenBGPd Route Server</title> <author>rdodin</author> <category>bgp</category> <category>ixp</category> <category>openbgp</category> <category>sr linux</category> <description>&lt;h1&gt;Basic IXP Lab with OpenBGPd Route Server&lt;/h1&gt;&lt;p&gt;Almost every Internet eXchange Point (IXP) leverages a Router Server (RS) to simplify peering between members of the exchange who exercise an open policy peering. A Route Server is a software component connected to the IXP network which acts as a BGP speaker with whom members peer to receive BGP updates from each other.&lt;/p&gt;&lt;p&gt;Nowadays, IXPs predominantly use [BIRD][bird] routing daemon as a Route Server, but for diversity and sustainability reasons [Route Server Support Foundation][rssf] initiated a program to introduce other software solutions, like [OpenBGPd][openbgpd], to the IXP market.&lt;/p&gt;&lt;p&gt;While OpenBGPd is not a new kid on the block of software BGP implementations, it is less known in the IXP domain (compared to BIRD). Lots of IXPs are interested in introducing OpenBGPd as a second Route Server in their networks and this lab opens the doors to explore &#34;OpenBGPd as a Route Server&#34; use case.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;Lab summary&lt;/h2&gt;&lt;p&gt;This blog posts is based on a lab example that builds a simple IXP network with a route server and two IXP members.&lt;/p&gt;&lt;p&gt;| Summary | || ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- || &lt;strong&gt;Lab name&lt;/strong&gt; | Basic IXP Lab with OpenBGPd Route Server || &lt;strong&gt;Lab components&lt;/strong&gt; | Nokia SR Linux, Arista cEOS and OpenBGPd nodes || &lt;strong&gt;Resource requirements&lt;/strong&gt; | :fontawesome-solid-microchip: 2 vCPU &lt;br/&gt;:fontawesome-solid-memory: 6 GB || &lt;strong&gt;Lab&lt;/strong&gt; | [hellt/obgpd-lab][lab] || &lt;strong&gt;Version information&lt;/strong&gt; | [&lt;code&gt;containerlab:0.32.4&lt;/code&gt;][clab-install], [&lt;code&gt;srlinux:22.6.4&lt;/code&gt;][srl-container], [&lt;code&gt;cEOS:4.28.0F&lt;/code&gt;][get-ceos], [&lt;code&gt;openbgpd:7.7&lt;/code&gt;][obgpd-container] || &lt;strong&gt;Authors&lt;/strong&gt; | Roman Dodin [:material-twitter:][rd-twitter] [:material-linkedin:][rd-linkedin] |&lt;/p&gt;&lt;h2&gt;Prerequisites&lt;/h2&gt;&lt;p&gt;The lab leverages the [Containerlab][containerlab] project to spin up a topology of network elements and couple it with containerized software such as openbgpd. A [one-click][clab-install] installation gets containerlab installed on any Linux system.&lt;/p&gt;&lt;p&gt;&lt;code&gt;bash title=&#34;Containerlab installation via installation-script&#34;bash -c &#34;$(curl -sL https://get.containerlab.dev)&#34;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Since containerlab uses containers as the nodes of a lab, Docker engine has to be [installed][docker-install] on the host system.&lt;/p&gt;&lt;h2&gt;Lab topology&lt;/h2&gt;&lt;p&gt;The goal of this lab is to give users a hands-on experience with OpenBGPd by providing a lab that mimics a trivialized IXP setup with two members exchanging their routers via a Route Server.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;phy topo&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/aa830e6e6c76e8eb33423d3947774c66/image.png&#34;&gt;&lt;/p&gt;&lt;p&gt;The setup consists of two routers - Nokia SR Linux and Arista EOS - acting as members connected to a common IXP LAN where a Route Server (OpenBGPd) is present.&lt;/p&gt;&lt;p&gt;Members of the exchange establish the BGP peering sessions with a Route Server over a common LAN segment and announce their &lt;code&gt;/32&lt;/code&gt; networks.&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;bgp&#34; src=&#34;https://gitlab.com/rdodin/pics/-/wikis/uploads/d4a6ae3b9c63171e0d30a93cc432a9d4/image.png&#34;&gt;&lt;/p&gt;&lt;p&gt;The OpenBGPd-based Route Server is configured to announce the routes it receives to connected peers and thus enables a core Route Server functionality.&lt;/p&gt;&lt;h2&gt;Obtaining container images&lt;/h2&gt;&lt;p&gt;This lab features three different products:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nokia SR Linux - IXP member role&lt;/li&gt;&lt;li&gt;Arista EOS - IXP member role&lt;/li&gt;&lt;li&gt;OpenBGPd - Route Server role&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For containerlab to be able to start up the lab, the relevant container images need to be available.&lt;/p&gt;&lt;p&gt;| Image | How to get it? || -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- || Nokia SR Linux | [Nokia SR Linux container image][srl-container] is freely available for anyone to use and can be pulled as easy as &lt;code&gt;docker pull ghcr.io/nokia/srlinux:22.6.4&lt;/code&gt; || Arista EOS | Arista EOS containerized version is called cEOS and can be obtained by registering on Arista website and downloading an ...&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2022/basic-ixp-lab-with-openbgpd-route-server/</link> <pubDate>Fri, 11 Nov 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/basic-ixp-lab-with-openbgpd-route-server/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/basic-ixp-lab-with-openbgpd-route-server/</guid> </item> <item> <title> Design, Deploy, And Operate With Nokia Data Center Fabric Solution</title> <category>fss</category> <category>media</category> <category>packet pushers</category> <category>podcast</category> <description>&lt;h1&gt;:material-podcast: Design, Deploy, And Operate With Nokia Data Center Fabric Solution&lt;/h1&gt;&lt;p&gt;&lt;small&gt;:material-podcast: &lt;a href=&#34;https://packetpushers.net/podcast/heavy-networking-653-design-deploy-and-operate-with-nokia-data-center-fabric-solution-sponsored/&#34;&gt;Packet Pushers&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;&lt;p&gt;In this Heavy Networking piece we’re talking data center operations and automation. Data centers aren’t immune from the pressures being felt across the IT organization: things like enabling new applications and services more quickly, getting better visibility to monitor performance and speed up troubleshooting, and tying into new capabilities that come from automation, APIs, containers, and microservices.&lt;/p&gt;&lt;p&gt;Today’s sponsor, Nokia, has been thinking about these pressures, and is here to talk about its fabric-based approach to the data center. That approach includes its SR Linux network OS, its Fabric Services System intent-based platform, its NetOps Development Kit, or NDK, and how all this ties together to address your operational life cycle across Day zero, Day 1, Day Two, and beyond.&lt;/p&gt;&lt;div class=&#34;iframe-audio2-container&#34;&gt;&lt;iframe width=&#34;320&#34; height=&#34;30&#34; src=&#34;https://packetpushers.net/?powerpress_embed=54285-podcast&amp;amp;powerpress_player=mediaelement-audio&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;Participants: &lt;a href=&#34;https://www.linkedin.com/in/bruce-wallis-77755a129/&#34;&gt;:material-linkedin:&lt;/a&gt; Bruce Wallis&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2022/material-podcast-design-deploy-and-operate-with-nokia-data-center-fabric-solution/</link> <pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/material-podcast-design-deploy-and-operate-with-nokia-data-center-fabric-solution/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/material-podcast-design-deploy-and-operate-with-nokia-data-center-fabric-solution/</guid> </item> <item> <title>Configuration backup with Event Handler</title> <author>jbemmel</author> <category>backup</category> <category>config management</category> <category>event handler</category> <description>&lt;h1&gt;Configuration backup with Event Handler&lt;/h1&gt;&lt;p&gt;The year is 2023. You wake up to a subtle &#39;ping&#39; from your phone 📱, signifying there is a message from someone important. Still half asleep you reach out and grab it, glancing at the screen. It says: &#34;The network went out - you&#39;re fired!&#34;&lt;/p&gt;&lt;p&gt;Rollback to the present day, where I can confidentially share that this is exactly the kind of scenario that our engineers had in mind when they designed the new &lt;a href=&#34;https://learn.srlinux.dev/tutorials/programmability/event-handler/oper-group/oper-group-intro/&#34;&gt;Event Handler&lt;/a&gt; feature for SR Linux. Because you can never have enough flexibility to add just the right amount of automation, configuring things properly and - critically - keeping track of changes to the configuration (and whichever #!$!! person made them)&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;&lt;center&gt;&lt;img alt=&#34;image&#34; src=&#34;https://user-images.githubusercontent.com/2031627/198035448-1a2c3987-d2fb-48ff-81b8-2322498d40b9.png&#34;&gt;{: class=&#34;img-shadow&#34;}&lt;/center&gt;&lt;center&gt;&lt;small&gt;&#34;Backup config&#34; event handler instance config&lt;/small&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;To make things more practical, take a look at &lt;a href=&#34;https://github.com/jbemmel/opergroup-lab/blob/main/backup_config.py&#34;&gt;this Python script&lt;/a&gt; which uses &lt;a href=&#34;https://documentation.nokia.com/srlinux/22-6/SR_Linux_Book_Files/Event_Handler_Guide/eh-overview.html&#34;&gt;the Event Handler&lt;/a&gt; mechanism to scp a backup of the config to any destination of your choice, whenever something or someone commits a change.&lt;/p&gt;&lt;p&gt;``` py title=&#34;backup_config.py&#34; linenums=&#34;1&#34;import json, time&lt;/p&gt;&lt;h1&gt;main entry function for event handler&lt;/h1&gt;&lt;p&gt;def event_handler_main(in_json_str): # parse input json string passed by event handler in_json = json.loads(in_json_str) paths = in_json[&#34;paths&#34;] options = in_json[&#34;options&#34;] debug = options.get(&#34;debug&#34;) == &#34;true&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if debug: print( in_json_str )target = options.get(&#34;target&#34;, None)if target: timestamp = None for p in paths: if p[&#39;path&#39;]==&#34;system configuration last-change&#34;: timestamp = p[&#39;value&#39;] break # elif p[&#39;path&#39;] starts with &#34;system aaa authentication session&#34; ... if not timestamp: t = time.gmtime() # in UTC timestamp = &#39;{:04d}-{:02d}-{:02d}_{:02d}:{:02d}:{:02d}_UTC&#39;.format(t[0], t[1], t[2], t[3], t[4], t[5]) response = { &#34;actions&#34;: [ { &#34;run-script&#34;: { &#34;cmdline&#34;: f&#34;ip netns exec srbase-mgmt /usr/bin/scp /etc/opt/srlinux/config.json {target}/config-{timestamp}.json&#34; } } ] } return json.dumps(response)print( &#34;Error: no &#39;target&#39; defined&#34; )return { &#34;actions&#34;: [] }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;The script should be fairly self-explanatory: It gets the &lt;code&gt;target&lt;/code&gt; from the configuration and the timestamp of the change, and then invokes a standard Linux &lt;code&gt;scp&lt;/code&gt; command (making sure it runs in the correct &lt;a href=&#34;https://linuxhint.com/use-linux-network-namespace/&#34;&gt;network namespace&lt;/a&gt;). Although it does not currently do anything with the username, those skilled in the art will appreciate that this could easily be added.&lt;/p&gt;&lt;p&gt;!!!question Anyone stopped here for a moment thinking &#34;Why not use Git?&#34;. Valid question, and a reasonable enhancement to the backup function presented here.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;The reason plain `scp` has been used in this example is because `scp` is shipped with the linux subsystem of SR Linux, and `git` is not. When `git` becomes available on SR Linux, we may update this example with a `git`-friendly backup option.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The above is just a quick starting point of course - you may want to make it more elaborate and (for example) have the system send you a text for approval, with automatic rollback in case you don&#39;t approve within a certain amount of time (configurable). Or maybe you&#39;re thinking to add some Blockchain logic there, creating indisputable proof that things happened the way you say they did. Go for it![^1]&lt;/p&gt;&lt;p&gt;My point is simple: You need a truly open system. A platform that allows you to configure and automate things the way you like to do them, unrestricted by vendor imposed limitations or poor product design choices. Because if not, one day you may find yourself waking up to that &#39;ping&#39;. Root cause? You didn&#39;t pick that truly open network platform when you had the chance...&lt;/p&gt;&lt;p&gt;!!! note &#34;Disclaimer&#34; Events and people referenced in this story are fictional. Any resemblance to existing persons or events is completely accidental. And we both know this would never happen to you, right? Because you always make the right choices :man_raising_hand:&lt;/p&gt;&lt;p&gt;[^1]: Micro Python backend that powers the Event Handler framework doesn&#39;t allow you to install extra packages. But you can use external APIs via standard lib HTTP client and integrate with them to build advanced pipelines. Another option is to leverage the &lt;code&gt;run-script&lt;/code&gt; action and call an external binary/script that can leverage external dependencies.&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2022/configuration-backup-with-event-handler/</link> <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/configuration-backup-with-event-handler/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/configuration-backup-with-event-handler/</guid> </item> <item> <title>SR Linux Blog Launch</title> <author>rdodin</author> <category>markdown</category> <description>&lt;h1&gt;SR Linux Blog Launch&lt;/h1&gt;&lt;p&gt;Openness, extensibility, innovation and community focus make a large part of the Nokia SR Linux core. Mix it up with our engineering background and you get a resource where we share technical content in the &lt;em&gt;engineers-to-engineers&lt;/em&gt; fashion.&lt;/p&gt;&lt;p&gt;Today we would like to take it one step further and augment the &lt;strong&gt;learn.srlinux.dev&lt;/strong&gt; portal with a community blog section where Nokia engineers and our community members can post content relevant to modern network technologies.&lt;/p&gt;&lt;p&gt;This blog post explains how to contribute a blog article to our portal and what visual candies you can use to make your post look awesome.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;!!!question &#34;What should I write about? Or should I even start writing?&#34; Likely the hardest thing in writing is to start. You may have dozens of doubts preventing you start writing.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;*Is this interesting to anyone? Isn&#39;t it too obvious? Is it too short/long?*The best advice here might be just to start writing and reiterate as you go. Nothing is perfect, and we welcome all to embrace the joy of writing, which helps to structure your own thoughts and get a firmer grip on the topic.SR Linux appreciates modern network architectures, network automation/orchestration and programmability. Anything that falls under and in-between these domains will make a great blog post.&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Creating a blog post&lt;/h2&gt;&lt;p&gt;Did you decide to contribute a blog post? That&#39;s great. Here is what you need to do.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Create a file under &lt;code&gt;./docs/blog/posts/&amp;lt;year&amp;gt;/&amp;lt;your-filename&amp;gt;.md&lt;/code&gt;. A &lt;code&gt;&amp;lt;year&amp;gt;&lt;/code&gt; is in the &lt;code&gt;YYYY&lt;/code&gt; format and stands for the year the post was authored. The filename you choose for your post is completely up to you and doesn&#39;t affect a URL or title of the blog post.&lt;/li&gt;&lt;li&gt;Write :smile: Use the classic markdown syntax and optionally apply our &lt;a href=&#34;#styling&#34;&gt;advanced styling&lt;/a&gt; for visual dominance.&lt;/li&gt;&lt;li&gt;Add a [date][date] to the post metadata.&lt;/li&gt;&lt;li&gt;Add yourself as a new &lt;a href=&#34;#authors&#34;&gt;author&lt;/a&gt; if this is your first contribution.&lt;/li&gt;&lt;li&gt;Create a new git branch and commit your post.&lt;/li&gt;&lt;li&gt;Check how your article looks using the live web server started with the &lt;code&gt;make serve-insiders&lt;/code&gt; target[^1].&lt;/li&gt;&lt;li&gt;If all looks great, raise a PR with your work so we can review and merge it.&lt;/li&gt;&lt;li&gt;Profit!&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;Authors&lt;/h2&gt;&lt;p&gt;We want to give credit to the authors. To make yourself known to the community, please add an entry with your information to the [&lt;code&gt;.authors.yml&lt;/code&gt;][authors-file] file that lists authors. Once added, you can add yourself to the frontmatter of the blog post:&lt;/p&gt;&lt;h2&gt;```yaml&lt;/h2&gt;&lt;p&gt;authors: - rdodin #(1)!&lt;/p&gt;&lt;hr&gt;&lt;p&gt;```&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;rdodin&lt;/code&gt; is a key used in the &lt;code&gt;.authors.yml&lt;/code&gt; file for a particular authors. Multiple authors can be added to the list of authors&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;Styling&lt;/h2&gt;&lt;p&gt;This portal uses the famous &lt;a href=&#34;https://squidfunk.github.io/mkdocs-material/&#34;&gt;mkdocs-material&lt;/a&gt; documentation theme. This theme packs a lot of UX improvements on top of classic markdown syntax. Knowing how to use those additional elements can make your post look awesome both from visual and user experience angles.&lt;/p&gt;&lt;p&gt;We would like to highlight a few UI elements we use all the time and hope you&#39;ll also like them.&lt;/p&gt;&lt;p&gt;!!!tip Check the &lt;a href=&#34;https://squidfunk.github.io/mkdocs-material/reference/&#34;&gt;mkdocs-material reference&lt;/a&gt; for a deep dive in the ocean of options and elements mkdocs-material theme provides.&lt;/p&gt;&lt;h3&gt;Tabs&lt;/h3&gt;&lt;p&gt;Tabs help to visually organize the content and improve readability an awful lot.&lt;/p&gt;&lt;p&gt;``` title=&#34;Content tabs with code blocks&#34;=== &#34;C&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;``` c#include &amp;lt;stdio.h&amp;gt;int main(void) { printf(&#34;Hello world!\n&#34;); return 0;}```&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;=== &#34;C++&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;``` c++#include &amp;lt;iostream&amp;gt;int main(void) { std::cout &amp;lt;&amp;lt; &#34;Hello world!&#34; &amp;lt;&amp;lt; std::endl; return 0;}```&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;div class=&#34;result&#34; markdown&gt;=== &#34;C&#34; ``` c #include &lt;stdio.h&gt; int main(void) { printf(&#34;Hello world!\n&#34;); return 0; } ```=== &#34;C++&#34; ``` c++ #include &lt;iostream&gt; int main(void) { std::cout &lt;&lt; &#34;Hello world!&#34; &lt;&lt; std::endl; return 0; } ```&lt;/div&gt;&lt;h3&gt;Code&lt;/h3&gt;&lt;p&gt;Nowadays, code is everywhere. With a few styling aids you can make your code blocks look shart and expressive.&lt;/p&gt;&lt;p&gt;A regular code block with a syntax highlighting uses code fences style:&lt;/p&gt;&lt;p&gt;&lt;code&gt;markdown title=&#34;Code block&#34;``` pyimport tensorflow as tf```&lt;/code&gt;&lt;/p&gt;&lt;div class=&#34;result&#34; markdown&gt;``` pyimport tensorflow as tf```&lt;/div&gt;&lt;h4&gt;Title&lt;/h4&gt;&lt;p&gt;To add a title to a code block, use the &lt;code&gt;title&lt;/code&gt; attribute:&lt;/p&gt;&lt;p&gt;&lt;code&gt;markdown title=&#34;Code block with title&#34;``` py title=&#34;bubble_sort.py&#34;def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] &amp;gt; items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j]```&lt;/code&gt;&lt;/p&gt;&lt;div class=&#34;result&#34; markdown&gt;``` py title=&#34;bubble_sort.py&#34;def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] &gt; items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j]```&lt;/div&gt;&lt;h1&gt;...&lt;/h1&gt;</description><link>https://learn.srlinux.dev/blog/2022/sr-linux-blog-launch/</link> <pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/sr-linux-blog-launch/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/sr-linux-blog-launch/</guid> </item> <item> <title> DevOps Approaches for Enhanced NetOps with Nokia Data Center Fabric Solution</title> <category>demo</category> <category>media</category> <category>nfd</category> <category>presentation</category> <description>&lt;h1&gt;:material-youtube: DevOps Approaches for Enhanced NetOps with Nokia Data Center Fabric Solution&lt;/h1&gt;&lt;p&gt;&lt;small&gt;:material-youtube: &lt;a href=&#34;https://techfieldday.com/video/devops-approaches-for-enhanced-netops-with-nokia-data-center-fabric-solution/&#34;&gt;NFD 29&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;&lt;p&gt;This presentation provides a quick review and update of the Nokia Data Center Fabric solution, and a review of how DevOps approaches may be adapted for data center fabric NetOps. This is followed by a demo featuring how Nokia SR Linux supports network application warm restart.&lt;/p&gt;&lt;div class=&#34;iframe-container&#34;&gt;&lt;iframe width=&#34;100%&#34; src=&#34;https://www.youtube.com/embed/-r9wu6KruE4&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;Participants: &lt;a href=&#34;https://www.linkedin.com/in/bruce-wallis-77755a129/&#34;&gt;:material-linkedin:&lt;/a&gt; Bruce Wallis&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2022/material-youtube-devops-approaches-for-enhanced-netops-with-nokia-data-center-fabric-solution/</link> <pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/material-youtube-devops-approaches-for-enhanced-netops-with-nokia-data-center-fabric-solution/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/material-youtube-devops-approaches-for-enhanced-netops-with-nokia-data-center-fabric-solution/</guid> </item> <item> <title> Develop Custom Network Apps With Nokia’s SR Linux NDK</title> <category>media</category> <category>ndk</category> <category>packet pushers</category> <category>podcast</category> <description>&lt;h1&gt;:material-podcast: Develop Custom Network Apps With Nokia’s SR Linux NDK&lt;/h1&gt;&lt;p&gt;&lt;small&gt;:material-podcast: &lt;a href=&#34;https://packetpushers.net/podcast/tech-bytes-develop-custom-network-apps-with-nokias-sr-linux-ndk-sponsored/&#34;&gt;Packet Pushers&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;&lt;p&gt;In this Tech Bytes podcast we talk with sponsor Nokia about its SR Linux network OS. More specifically, because SR Linux is open, customers can write homegrown applications to solve specific problems with the network OS using Nokia’s &lt;a href=&#34;../../../ndk/index.md&#34;&gt;NetOps Development Kit (NDK)&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The NDK provides documentation and examples to help you write apps quickly and easily. The NDK supports industry standards including YANG, gRPC, and gNMI. Is this a good idea? Do customers actually do this?&lt;/p&gt;&lt;div class=&#34;iframe-audio2-container&#34;&gt;&lt;iframe width=&#34;320&#34; height=&#34;30&#34; src=&#34;https://packetpushers.net/?powerpress_embed=54060-podcast&amp;amp;powerpress_player=mediaelement-audio&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;Participants: &lt;a href=&#34;https://www.linkedin.com/in/jonathon-lundstrom-2b6034a/&#34;&gt;:material-linkedin:&lt;/a&gt; Jon Lundstrom&lt;/p&gt;</description><link>https://learn.srlinux.dev/blog/2022/material-podcast-develop-custom-network-apps-with-nokias-sr-linux-ndk/</link> <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><source url="https://learn.srlinux.dev/feed_rss_created.xml">Learn SR Linux</source><comments>https://learn.srlinux.dev/blog/2022/material-podcast-develop-custom-network-apps-with-nokias-sr-linux-ndk/#__comments</comments><guid isPermaLink="true">https://learn.srlinux.dev/blog/2022/material-podcast-develop-custom-network-apps-with-nokias-sr-linux-ndk/</guid> </item> </channel></rss>